# 상속(Inheritance)   
* 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것.   
* 생성자와 초기화 블럭은 상속되지 않고 멤버만 상속된다.   
* 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.   
```java

 class Parent { }
  class Child extends Parent { }
   class GrandChild extends Child { }
   ```   

조상 클래스 : 부모(parent)클래스, 상위(super)클래스, 기반(base)클래스.   

자손 클래스 : 자식(child)클래스, 하위(sub)클래스, 파생된(derived)클래스.   


### 오버라이딩overriding   
>조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것.   

### 오버라이딩 조건
 * 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와 이름, 매개변수, 반환타입이 같아야 한다.   
 * 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.   
 * 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.   
 * 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.   



 > super - 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수.  
 > this.x - 자손 클래스에 선언된 멤버변수.  
 > super.x - 조상 클래스로부터 상속받은 멤버변수.   
 > super ( ) - 조상 클래스의 생성자, 조상 클래스의 생성자를 호출하는데 사용.   
 
 ----------------

### 제어자 modifier   
 * 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다.   
 * 접근 제어자는 한 개만 사용 가능하고 그 외는 함께 사용 가능하다.   

접근 제어자   
> public, protected, default, private   

그 외   
> static, final, abstract, native, transient, synchronized, volatile, strictfp   
>

-----------------------

### static - 클래스의, 공통적인
 * 사용되는 곳 - 멤버변수, 메서드, 초기화 블럭.
 #### static 멤버변수
  * 모든 인스턴스에 공통으로 사용되는 클래스변수가 된다.
  * 클래스변수는 인스턴스를 생성하지 않고도 사용 가능하다.
  * 클래스가 메모리에 로드될 때 생성된다.
 #### static 메서드
  * 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
  * static메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.

--------------------

### final - 마지막의, 변경될 수 없는.
 * 사용되는 곳 - 클래스, 메서드, 멤버변수, 지역변수.
 #### final 클래스
  * 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
  * 다른 클래스의 조상이 될 수 없다.
 #### final 메서드
  * 변경될 수 없는 메서드. 오버라이딩을 통해 제정의 될 수 없다.
 #### final 멤버변수, 지역변수
  * 값을 변경할 수 없는 상수가 된다.

-----------------

### abstract 추상의, 미완성의
 * 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언.
 * 사용되는 곳 - 클래스, 메서드
 #### abstract 클래스
  * 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.
 #### abstract 메서드
  * 선언부만 작성하고 구현부는 작성하지 않은 추상 메서드임을 알린다.

--------------------

# 접근 제어자 access modifier
 * public - 접근 제한이 없다. 하나의 소스파일에는 하나의 public 클래스만 존재할 수 있다.
 * protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
 * (default) - 같은 패키지 내에서만 접근이 가능하다.
 * private - 같은 클래스 내에서만 접근이 가능하다. 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없다.
 
 ### 사용가능한 접근 제어자
  * 클래스 - public, (default)
  * 메서드, 멤버변수 - public, protected, (default), private
  * 지역변수 - 없음.   
 

## 접근 제어자를 이용한 캡슐화
 ### 접근 제어자를 사용하는 이유
  * 외부로부터 데이터를 보호하기 위해서
  * 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서
 
 -----------------------
 
 
# 제어자의 조합
 * 사용가능한 제어자
    * 클래스 - public, (default), final, abstract
    * 메서드 - 모든 접근 제어자, final, abstract, static
    * 멤버변수 - 모든 접근 제어자, final, static
    * 지역변수 - final
   
   
 > 메서드에 static과 abstract를 함께 사용할 수 없다. static은 몸통이 있는 메서드에만 사용할 수 있다.
 > 클래스에 abstract와 final을 동시에 사용할 수 없다. 서로 모순된다.
 > abstract메서드의 접근 제어자가 private일 수 없다. abstract메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없다.
 > 메서드에 private과 final을 같이 사용할 필요는 없다. 하나만 사용해도 의미가 충분하다.


# 다형성 polymorphism
 ```java
 Tv t = new CaptionTv( );
 ```
 
 > 조상클래스 타입의 참조변수로 자손클래스의  인스턴스를 참조할 수 있도록 한 기능.
 > 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.

-----------------------------

# instanceof 연산자
 * 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 사용한다.
 * 연산의 결과로 boolean값인 true와 false 중 하나를 반환한다.
 * 어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.
 ```java
 if ( c instanceof FireEngine)
```

------------------------------

### 참조변수와 인스턴스의 연결
 * 조상 클래스에 선언된 멤버변수와 같은 이름의 인스턴스변수를 자손 클래스에 중복으로 정의했을 때,   
   참조변수의 타입에 따라 호출시 결과가 달라진다.
 * 메서드의 경우 인스턴스 클래스의 메서드가 호출되지만, 변수는 참조변수 타입을 따라간다.

-----------------------------------

# Vector클래스
 * 동적으로 크기가 관리되는 객체배열.
 
  ```java
  Vector( )
  ```
   >10개의 객체를 저장할 수 있는 Vector인스턴스를 생성. 10개 이상의 인스턴스가 저장되면 자동으로 크기가 증가된다.
 
```java
boolean add(Obect o)
```
  > Vector에 객체를 추가한다.
 
  ```java
  boolean remove(Object o)
  ```
   > Vector에 저장되어 있는 객체를 제거한다.
  
  ```java
  boolean isEmpty( )
  ```
   > Vector가 비어있는지 검사한다.
  
  ```java
  Object get (int index)
  ```
  > 지정된 위치(index)의 객체를 반환한다. 반환타입이 Object이므로 적절한 타입으로의 형변환이 필요하다.
  
  ```java
  int size ( )
  ```
   > Vector에 저장된 객체의 개수를 반환한다.

-------------------------

# 추상클래스 abstract class
 * 미완성 메서드(추상 메서드)를 포함하고 있는 클래스.
## 추상메서드
 * 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 메서드.

-------------------------

# 인터페이스interface

*  일종의 추상클래스로 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다.
 ```java
 interface 인터페이스 이름 {
	public static final 타입 상수이름 = 값;
	public abstract 메서드이름 (매개변수 목록) ;   }
  ```
  
 *  모든 멤버변수는 public static final이어야 하며 생략 가능하다.
 * 모든 메서드는 public abstract이어야 하며, 생략 가능하다.
 * JDK1.8 이 후 static 메서드와 (default) 메서드를 허용한다.
### 인터페이스의 상속
 * 인터페이스는 인터페이스로부터만 상속받을 수 있으며, 클래스와 달리 다중상속이 가능하다.
### 인터페이스 구현
 * 인터페이스 자체만으로 인스턴스를 생성할 수 없으며, 구현을 통해 추상 메서드를 완성해야 한다.
 ```java
 class 클래스이름 implements 인터페이스이름 { ... }
 ```
 
 * 구현하는 인터페이스의 메서드 중 일부만 구현한다면 abstract를 붙여서 추상클래스로 선언해야 한다.
 ```java
 abstract class 클래스이름 implements 인터페이스이름 { ... }
 ```
 
### 인터페이스를 이용한 다형성
 * 인터페이스를 클래스가 구현했을 때, 인스턴스를 인터페이스 타입의 참조변수로 참조하는 것이 가능하다.
  ```java
  Fightable f = (Fightable) new Fighter ( );
  Fightable f = new Fighter ( ) ;
  ```
  
 > 인터페이스는 메서드의 매개변수의 타입으로 사용될 수 있다.
  ```java
  void attack (Fightable f ) { ... }
  ```
  
 > 메서드의 리턴타입으로 인터페이스의 타입을 지정하는 것이 가능하다.
 ```java
 Fightable method ( ) { ... }
```

> 리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.
### 인터페이스의 장점
> 개발시간을 단축시킬 수 있다.   
> 표준화가 가능하다.   
> 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다.   
> 독립적인 프로그래밍이 가능하다.   


# 내부클래스 inner class
 * 긴밀한 관계가 있는 클래스를 클래스 내부에 선언하는 클래스.   
 * 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있고 코드의 복잡성을 줄일 수 있다.(캡슐화)   
 * 인스턴스 클래스 - 외부 클래스의 멤버변수 선언위치에 선언하며, 외부 클래스의 인스턴스멤버들과 관련된 작업에 사용될 목적으로 선언된다.   
 
 > 스태틱 클래스 - 외부 클래스의 멤버변수 선언위치에 선언하며, static메서드에서 사용될 목적으로 선언된다.   
 > 지역 클래스 - 외부 클래스의 메서드나 초기화블럭 안에 선언하며, 선언된 영역 내부에서만 사용될 수 있다.   
 > 익명 클래스 anonymous class - 선언과 객체의 생성을 동시에 하는 이름없는 일회용 클래스.   
 
 ```java
 class Outer {
	class InstanceInner {...}
	static class StaticInner {...}
	void myMethod ( ) {
		class LocalInner {...}   }  }
    ```
    
 > 내부 인스턴스클래스의 인스턴스를 생성하려면 외부 클래스의 인스턴스를 먼저 생성해야 한다.
