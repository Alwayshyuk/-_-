# 지네릭스Generics
## 지네릭스란?
지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입체크(compile-time type check)를 해주는 기능이다.     
객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.     


지네릭스의 장점
> 타입 안정성을 제공한다.      
> 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.    

## 지네릭스의 선언
지네릭스 타입은 클래스와 메서드에 선언할 수 있다.
```java
class Box<T>{		//지네릭 타입 T를 선언
	T item;
	
	void setItem(T item) {
		this.item = item;
	}
	T getItem() { return item; }
}
```
> 클래스 이름 옆에 < T >를 붙이고 Object를 모두 T로 바꿧다.
 Box< T >에서 T를 타입변수type variable이라고 하며, Type의 첫 글자에서 따온 것이다.      
 타입 변수는 다른 것을 사용해도 되며, ArrayList< E >는 요소Element에서 E를 따왓다.    
 타입 변수가 여러 개인 경우 Map<K, V>와 같이 컴마,를 구분자로 나열하면 된다.     
 
 ```java
Box<String> b = new Box<String>();	//타입 T대신, 실제 타입을 지정
b.setItem(new Object());		    //에러, String타입 외에는 지정불가.
b.setItem("ABC");
String item = b.getItem();		    //형변환이 필요없음.

//String을 지정해줌으로 아래와 같아진다.
class Box{
  String item;
  void setItem(String item) { this.item = item;}
  String getItem()    { return item; }
```
지네릭 클래스가 된 Box클래스의 객체를 생성할 때는 다음과 같이 참조변수와 생성자에 타입T대신 사용될 실제 타입을 지정해주어야 한다.   

#### 지네릭스 용어
* class Box< T > { }
> Box< T > 지네릭 클래스. 'T의 Box' 또는 'T Box'라고 읽는다.     
> T 타입 변수 또는 타입 매개변수.(T는 타입문자)      
> Box 원시타입(raw type)
* Box< String > b = new Box< String >();
> 매개변수에 타입을 지정하는 것을 지네릭 타입 호출 이라고 한다.     
> 지정된 타입String을 매개변수화된 타입 이라고 한다.     

	
Box< String >과 Box< Integer >는 지네릭 클래스 Box< T >에 서로 다른 타입을 대입하여 호출한 것일 뿐,     
이 둘이 별개의 클래스를 의미하는 것은 아니다. add(3,5)와 add(2,4)가 같은 메서드를 호출하는 것과 같은 것이다.			

#### 지네릭스의 제한
지네릭 클래스 Box의 객체를 생성할 때, 객체별로 다른 타입을 지정하는 것은 적절하다.
```java
  Box<Apple> appleBox = new Box<Apple>();
  Box<Grape> grapeBox = new Box<Grape>();
  ```
그러나 모든 객체에 대해 동일하게 동작해야하는 static멤버에 타입 변수 T를 사용할 수 없다.    
	T는 인스턴스변수로 간주되기 때문이다.(static멤버는 인스턴스 변수를 참조할 수 없다)
```java
class Box<T>
  static T item;				//에러
  static int compare(T t1, T t2) { ... }	//에러
```

static멤버는 타입 변수에 지정된 타입, 즉 대입된 타입의 종류에 관계없이 동일한 것이어야 하기 때문이다.    
지네릭 타입의 배열을 생성하는 것은 허용되지 않는다. 

```java
class Box<T>	{
	T[] itemArr;				//ok. T타입의 배열을 위한 참조변수
	...
	T[] tmpArr = new T[item.length];
	...
	return tmpArr
}
```
지네릭 배열을 생성할 수 없는 것은 new 연산자 때문인데, 이 연산자는 컴파일 시점에 타입 T가 뭔지 정확히 알아야 한다.    
그런데 위의 코드에 정의된 Box<T>클래스를 컴파일하는 시점에서는 T가 어떤 타입이 될지 전혀 알 수 없다.    
instanceof연산자도 new연산자와 같은 이유로 T를 피연산자로 사용할 수 없다.       

# 지네릭 클래스의 객체 생성과 사용

```java
class Box<T>	{
	ArrayList<T> list = new ArrayList<T>();
	
	void add(T item)				{list.add(item);}
	T get(int i)						{return lsit.get(i);}
	ArrayList<T> getList()	{return list;}
	int size()							{return list.size()}
	public String toString	{return list.toString();}
}
	
//Box< T >의 객체를 생성할 때는 참조변수와 생성자에 대입된 타입(매개변수화된 타입)이 일치해야 한다.
Box<Apple> appleBox = new Box<Apple>();
Box<Apple> appleBox = new Box<Grape>();						//에러
	
//두 타입이 상속관계에 있어도 마찬가지다. Apple이 Fruit의 자손이라고 가정.
Box<Fruit> appleBox = new Box<Apple>();						//에러
	
//단, 두 지네릭 클래스의 타입이 상속관계에 있고, 대입된 타입이 같은 것은 괜찮다.
//FruitBox는 Box의 자손이라고 가정.
Box<Apple> appleBox = new FruitBox<Apple>();
	
//추정이 가능한 경우 타입을 생략할 수 있다.
//참조변수의 타입으로부터 Box가 Apple타입의 객체만 저장한다는 것을 알 수 있기 때문에,
//생성자에 반복해서 타입을 지정해주지 않다고 되는 것이다. 아래 두 문장은 동일하다.
Box<Apple> appleBox = new Box<Apple>();
Box<Apple> appleBox = new Box<>();
	
//생성된 Box<T>의 객체에 'void add(T item)'으로 객체를 추가할 때, 대입된 타입과 다른 타입의 객체는 추가할 수 없다.
Box<Apple> appleBox = new Box<Apple>();
appleBox.add(new Apple());
appleBox.add(new Grape());		//에러
	
//그러나 타입T가 Fruit인 경우 'void add(Fruit item)'가 되므로 Fruit의 자손들은 이 메서드의 매개변수가 될 수 있다.
Box<Fruit> fruitBox = new Box<Fruit>();
fruitBox.add(new Fruit());
fruitBox.add(new Apple());
```
	
```java
class Fruit {public String toString() { return "Fruit";}}
class Apple extends Fruit {public String toString() { return "Apple";}}
class Grape extends Fruit {public String toString() { return "Grape";}}
class Toy {public String toString()	{ return "Toy";}}

public class FruitBoxEx1 {
  public static void main(String[] args) {
    Box<Fruit> fruitBox = new Box<Fruit>();
    Box<Apple> appleBox = new Box<Apple>();
    Box<Toy> toyBox = new Box<Toy>();
//  Box<Grape> grapeBox = new Box<Apple>();		//에러, 타입 불일치
		
    fruitBox.add(new Fruit());
    fruitBox.add(new Apple());					//void add(Fruit item)
		
    appleBox.add(new Apple());
    appleBox.add(new Apple());
//  appleBox.add(new Toy());					//에러, Box<Apple>에는 Apple만 담을 수 있음
		
		toyBox.add(new Toy());
//  toyBox.add(new Apple());					//에러, Box<Toy>에는 Toy만 담을 수 있음
		
		System.out.println(fruitBox);				//[Fruit, Apple]
		System.out.println(appleBox);				//[Apple, Apple]
		System.out.println(toyBox);					//[Toy]
	}
}
class Box<T>{
	ArrayList<T> list = new ArrayList<T>();
	void add(T item) { list.add(item);}
	T get(int i)	 { return list.get(i);}
	int size()		 { return list.size();}
	public String toString() { return list.toString();}
}
```       
  
## 제한된 지네릭 클래스     
  지네릭 타입에 extends를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.
  
```java
class FruitBox<T extends Fruit> {					//Fruit의 자손만 타입으로 지정가능
  ArrayList<T> list = new ArrayList<T>();
	...
}
	
FruitBox<Apple> appleBox = new FruitBox<Apple>();
FruitBox<Toy>	toyBox = new FruitBox<Toy>();				//에러. Toy는 Fruit의 자손이 아님
	
//add()의 매개변수의 타입 T도 Fruit과 그 자손 타입이 될 수 있으므로, 여러 과일을 담을 수 있는 상자가 가능하게 된다.
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
fruitBox.add(new Apple());	//Apple이 Fruit의 자손
fruitBox.add(new Grape());	//Grape가 Fruit의 자손
//타입 매개변수 T에 Object를 대입하면 모든 종류의 객체를 저장할 수 있게 된다.
```
  
```java
//만일 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요하면,
//implement가 아니라 extends를 사용한다.
interface Eatable {}
class FruitBox<T extends Eatable> {...}
//클래스 Fruit의 자손이면서 Eatable 인터페이스도 구현해야한다면 & 기호로 연결한다.
class FruitBox<T extends Fruit & Eatable> {...}
//FruitBox에는 Fruit의 자손이면서 Eatable을 구현한 클래스만 타입 매개변수 T에 대입될 수 있다.
```
  
```java
class Fruit implements Eatable {
  public String toString() {return "Fruit";}
}
class Apple extends Fruit {public String toString() { return "Apple";}}
class Grape extends Fruit {public String toString() { return "Grape";}}
class Toy				   {public String toString() { return "Toy";}}

interface Eatable{}

public class FruitBoxEx2 {

	public static void main(String[] args) {
		FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
		FruitBox<Apple> appleBox = new FruitBox<Apple>();
		FruitBox<Grape> grapeBox = new FruitBox<Grape>();
//  FruitBox<Grape> grapeBox = new FruitBox<Apple>();	//에러, 타입 불일치
//  FruitBox<Toy>	  toyBox   = new FruitBox<Toy>();		//에러

		fruitBox.add(new Fruit());
		fruitBox.add(new Apple());
		fruitBox.add(new Grape());
		appleBox.add(new Apple());
//  appleBox.add(new Grape());			//에러, Grape는 Apple의 자손이 아님
		grapeBox.add(new Grape());
		
		System.out.println(fruitBox);		//[Fruit, Apple, Grape]
		System.out.println(appleBox);		//[Apple]
		System.out.println(grapeBox);		//[Grape]
	}
}
class FruitBox<T extends Fruit & Eatable> extends Box<T>{}
class Box<T>{
	ArrayList<T> list = new ArrayList<T>();
	void add(T item)	{list.add(item);	}
	T get(int i)		{return list.get(i);}
	int size()			{return list.size();}
	public String toString() {return list.toString();}
}
```
## 와일드 카드
```java
class Juicer {
	static Juice makeJuice(FruitBox<Fruit> box) {			//<Fruit>으로 지정
		String tmp = " ";
		for(Fruit f : box.getList())	tmp += f + " ";
		return new Juice(tmp);
	}
}
//Juicer클래스는 지네릭 클래스가 아닌데다, 지네릭 클래스라고 해도 static메서드에는 타입 매개변수 T를 매개변수에 사용할 수 없으므로
//아예 지네릭스를 적용하지 않던가, 위와 같이 타입 매개변수 대신, 특정 타입을 지정해줘야 한다.

FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new appleBox<Apple>();
...
System.out.println(Juicer.makeJuice(fruitBox));		//FruitBox<Fruit>
System.out.println(Juicer.makeJuice(appleBox));		//에러, FruitBox<Apple>
// 지네릭 타입을 FruitBox<Fruit>로 고정해 놓으면, FruitBox<Apple>타입의 객체 makeJuice()의 매개변수가 될 수 없으므로,
// 다음과 같이 여러가지 타입의 매개변수를 갖는 makeJuice()를 만들 수 밖에 없다.
	
static Juice makeJuice (FruitBox<Fruit> box) {
	String tmp = " ";
	for(Fruit f : box.getList()) tmp += f + " ";
	  return new Juice(tmp);
}
	
static Juice makeJuice(FruitBox<Apple> box) {
	String tmp = " ";
	for(Fruit f : box.getList()) tmp += f + " ";
	return new Juice(tmp);
 }
	
//그러나 위와 같이 오버로딩하면, 컴파일 에러가 발생한다. 지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않기 때문이다.
//지네릭 타입은 컴파일러가 컴파일할 때만 사용하고 제거해버린다. 그래서 위의 두 메서드는 오버로딩이 아니라
//메서드 중복 정의 이다.
```
	
이럴때 사용하기 위해 고안된 것이 와일드 카드이다.      
와일드 카드는 기호 '?'로 표현하는데, 와일드 카드는 어떠한 타입도 될 수 있다.      
'?'만으로는 Object타입과 다를 게 없으므로, extends와 super로 상한과 하한을 제한할 수 있다.     
* < ? extends T > 와일드 카드의 상한 제한. T와 그 자손들만 가능.         
* < ? super T > 와일드 카드의 하한 제한. T와 그 조상들만 가능.         
* < ? > 제한 없음. 모든 타입이 가능. < ? extends Object >와 동일.       


와일드 카드를 사용해서 makeJuice()의 매개변수 타입을 FruitBox< Fruit >에서        
FruitBox < ? extends Fruit >으로 바꾸면 다음과 같이 된다.
```java
static Juice (FruitBox<? extends Fruit> box {
  String tmp = "";
  for(Fruit f : box.getList()) tmp += f + " ";
  return new Juice(tmp);
}
```
이제 이 메서드의 매개변수로 FruitBox< Fruit >뿐 아니라, FruitBox< Apple >와 FruitBox< Grape >도 가능하게 된다.     

```java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();
	...
System.out.println(Juicer.makeJuice(fruitBox));
System.out.println(Juicer.makeJuice(appleBox));
```

매개변수의 타입을 FruitBox< ? extends Object >로 하면, 모든 종류의 FruitBox가 이 메서드의 매개변수로 가능해진다.     
대신 box의 요소가 Fruit의 자손이라는 보장이 없으므로 아래의 for문에서 box에 저장된 요소를 Fruit타입의 참조변수로 못받는다.

```java
static Juice makeJuice(FruitBox <? extends Object> box {
	String tmp = " ";
	for(Fruit f : box.getList())
		tmp += f + " ";			//에러. Fruit이 아닐 수 있음
	return new Juice(tmp);
```

그러나 실제로 테스트하면 문제없이 컴파일되는데 그 이유는 지네릭 클래스 FruitBox를 제한했기 때문이다.

```java
class FruitBox <T extends Fruit> extends Box<T> {}
```

컴파일러는 위 문장으로부터 모든 FruitBox의 요소들이 Fruit의 자손이라는 것을 알고 있으므로 문제 삼지 않는 것이다.

```java
import java.util.ArrayList;
class Fruit { public String toString() { return "Fruit";}}
class Apple extends Fruit { public String toString() { return "Apple";}}
class Grape extends Fruit { public String toString() { return "Grape";}}
class Juice {
	String name;
	
	Juice(String name) { this.name = name + "Juice";}
	public String toString() { return name;}
}
class Juicer{
	static Juice makeJuice(FruitBox<? extends Fruit> box) {
		String tmp = " ";
		
		for(Fruit f : box.getList())
			tmp += f + " ";
		return new Juice(tmp);
	}
}
public class FruitBoxEx3 {

	public static void main(String[] args) {
		FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
		FruitBox<Apple> appleBox = new FruitBox<Apple>();
		
		fruitBox.add(new Apple());
		fruitBox.add(new Grape());
		appleBox.add(new Apple());
		appleBox.add(new Apple());
		
		System.out.println(Juicer.makeJuice(fruitBox));
		System.out.println(Juicer.makeJuice(appleBox));
	}
}
class FruitBox <T extends Fruit> extends Box<T>{}
class Box<T>{
	ArrayList<T> list = new ArrayList<T>();
	void add(T item) { list.add(item);}
	T get(int i) { return list.get(i);}
	ArrayList<T> getList() { return list;}
	int size() { return list.size();}
	public String toString() { return list.toString();}
}
```

```java
import java.util.*;

class Fruit {
	String name;
	int weight;
	
	Fruit (String name, int weight){
		this.name = name;
		this.weight = weight;
	}
	public String toString() {return name + "(" + weight + ")";}
}
class Apple extends Fruit {
	Apple(String name, int weight){
		super(name, weight);
	}
}
class Grape extends Fruit {
	Grape(String name, int weight){
		super(name, weight);
	}
}
class AppleComp implements Comparator<Apple>{
	public int compare(Apple t1, Apple t2) {
		return t2.weight - t1.weight;
	}
}
class GrapeComp implements Comparator<Grape>{
	public int compare(Grape t1, Grape t2) {
		return t2.weight - t1.weight;
	}
}
class FruitComp implements Comparator<Fruit>{
	public int compare(Fruit t1, Fruit t2) {
		return t1.weight - t2.weight;
	}
}
public class FruitBoxEx4 {

	public static void main(String[] args) {
		FruitBox<Apple> appleBox = new FruitBox<Apple>();
		FruitBox<Grape> grapeBox = new FruitBox<Grape>();
		
		appleBox.add(new Apple("GreenApple", 300));
		appleBox.add(new Apple("GreenApple", 100));
		appleBox.add(new Apple("GreenApple", 200));
		
		grapeBox.add(new Grape("GreenGrape", 400));
		grapeBox.add(new Grape("GreenGrape", 300));
		grapeBox.add(new Grape("GreenGrape", 200));
		
		Collections.sort(appleBox.getList(), new AppleComp());
		Collections.sort(grapeBox.getList(), new GrapeComp());
		System.out.println(appleBox);			//[GreenApple(300), GreenApple(200), GreenApple(100)]
		System.out.println(grapeBox);			//[GreenGrape(400), GreenGrape(300), GreenGrape(200)]
		Collections.sort(appleBox.getList(), new FruitComp());
		Collections.sort(grapeBox.getList(), new FruitComp());
		System.out.println(appleBox);			//[GreenApple(100), GreenApple(200), GreenApple(300)]
		System.out.println(grapeBox);			//[GreenGrape(200), GreenGrape(300), GreenGrape(400)]
	}
}
class FruitBox<T extends Fruit> extends Box<T>{}
class Box<T>{
	ArrayList<T> list = new ArrayList<T>();
	
	void add(T item) {
		list.add(item);
	}
	T get(int i) {
		return list.get(i);
	}
	ArrayList<T> getList(){ return list;}
	int size() {
		return list.size();
	}
	public String toString() {
		return list.toString();
	}
}
```

이 예제는 Collections.sort()를 이용해서 appleBox와 grapeBox에 담긴 과일을 무게별로 정렬한다.     
이 메서드의 선언부는 다음과 같다

```java
static <T> void sort(List<T> list, Comparator<? super T> c)
```

static 옆에 있는 < T >는 메서드에 선언된 지네릭 타입이다. 이런 메서드를 지네릭 메서드라고 한다.    
첫 매개변수는 정렬 대상이고, 두 번째 매개변수는 정렬할 방법이 정의된 Comparator이다.     
Comparator의 지네릭 타입에 하한이 걸려있는 와일드 카드가 사용되었다.

```java
static <T> void sort(List<T> list, Comparator<T> c)
//와일드 카드를 사용하지 않았다고 가정

//매개변수 T에 Apple 대입
static void sort(List<Apple> list, Comparator<Apple> c)
//이것은 List<Apple>을 정렬하기 위해서는 Comparator<Apple>이 필요하다는 것을 의미한다.

//Comparator<Apple>을 구현한 AppleComp클래스를 정의
class AppleComp implements Comparator<Apple>{
	public int compare (Apple t1, Apple t2) {
		return t2.weight - t1.weight;
	}
}
//위의 코드는 문제가 없어보이나 Apple대신 Grape가 대입된다면 에러가 발생한다.     
//그래서 위 예제에서 같은 코드를 두 번 작성하였다.
```
AppleComp와 GrapeComp는 타입만 다를 뿐 완전히 같은 코드다.    
코드의 중복도 문제지만 새로운 Fruit의 자손이 생길 때마다 위와 같은 코드를 반복해서 만들어야 한다는 것이 더 문제이다.     
이 문제를 해결하기 위해 타입 매개변수에 하한 제한의 와일드 카드를 적용해야 한다.

```java
static void sort(List<Apple> list, Comparator<? super Apple> c_)
```
매개변수의 타입이 Comparator< ? super Apple >이라는 의미는 Comparator의 타입 매개변수로 Apple과 그 조상이 가능하다는 뜻이다.     
즉, Comparator< Apple >, Comparator< Fruit >, Comparator< Object > 중의 하나가 두 번재 매개변수로 올 수 있다는 뜻이다.

- Comparator< ? super Apple > : Comparator< Apple >, Comparator< Fruit >, Comparator < Object >
- Comparator< ? super Grape > : Comparator< Grape >, Comparator< Fruit >, Comparator < Object >

그래서 아래와 같이 FruitComp를 만들면, List< Apple >과 List< Grape >를 모두 정렬할 수 있다.     
비교의 대상이 되는 weight는 Apple과 Grape의 조상인 Fruit에 정의되어 있기 때문에 가능한 것이기도 하다.

```java
class FruitComp implements Comparator<Fruit> {
	public int compare(Fruit t1, Fruit t2) {
		return t1.weight - t2.weight;
	}
}
//List<Apple>과 List<Grape>를 모두 Comparator<Fruit>로 정렬
Collections.sort(appleBox.getList(), new FruitBox());
Collections.sort(grapeBox.getList(), new FruitBox());
```
이러한 장점 때문에 Comparator에는 항상 < ? super T >가 습관적으로 따라 붙는다.

## 지네릭 메서드

메서드의 선언부에 지네릭 타입이 선언된 메서드를 지네릭 메서드라 한다.     
앞에서 본 Collections.sort()가  지네릭 메서드이며, 지네릭 타입의 선언 위치는 반환타입 바로 앞이다.

```java
static <T> void sort (List<T> list, Comparator<? super T> c)
```

지네릭 클래스에 정의된 타입 매개변수와 지네릭 메서드에 정의된 타입 매개변수는 전혀 별개의 것이다.     
같은 타입 문자 T를 사용해도 같은 것이 아니다. 지네릭 메서드는 지네릭 클래스가 아닌 클래스에도 정의될 수 있다.

```java
class FruitBox<T> {
	...
	static <T> void sort(Luist<T> list, Comparator<? super T> c) {
		... }	}
```

위의 코드에서 지네릭 클래스 FruitBox에 선언된 타입 매개변수 T와 지네릭 메서드 sort()에 선언된 타입 매개변수 T는     
타입 문자만 같을 뿐 서로 다른 것이다.    
static멤버에는 타입 매개변수를 사용할 수 없지만, 이처럼 메서드에 지네릭 타입을 선언하고 사용하는 것은 가능하다.      
메서드에 선언된 지네릭 타입은 지역 변수를 선언한 것과 같다고 생각하면 이해가 쉽다.     
이 타입 매개변수는 메서드 내에서만 사용될 것이기 때문에 메서드가 static이건 아니던 상관없다.     
같은 이유로 내부 클래스에 선ㄴ언된 타입 문자가 외부 클래스의 타입 문자와 같아도 구별될 수 있다.       

앞서 나왔던 makeJuice()를 지네릭 메서드로 바꾸면 다음과 같다.

```java
static Juice makeJuice(FruitBox<? extends Fruit> box) {
	String tmp = "";
	for(Fruit f : box.getList()) tmp += f + " ";
	return new Juice(tmp);		}
	//>>>>>>
static <T extends Fruit> Juice makeJuice(FruitBox<T> box) {
	String tmp = "";
	for(Fruit f : box.getList())	tmp += f + " ";
return new Juice(tmp);			}

//이제 이 메서드를 호출할 때 다음과 같이 타입 변수에 타입을 대입해야 한다.
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<apple>();

System.out.println(Juicer.<Fruit>makeJuice(fruitBox));
System.out.println(Juicer.<Apple>makeJuice(appleBox));

//그러나 대부분의 경우 컴파일러가 타입을 추정할 수 있기 때문에 생략해도 된다.
//위 코드에서 fruitBox와 appleBox의 선언부에서 컴파일러가 대입된 타입을 추정할 수 있으므로 생략할 수 있다.
System.out.println(Juicer.makeJuice(fruitBox));		//대입된 타입을 생략할 수 있다.
System.out.println(Juicer.makeJuice(appleBox));

//한 가지 주의할 점은 지네릭 메서드를 호출할 때, 대입된 타입을 생략할 수 없는 경우에는 참조변수나 클래스 이름을 생략할 수 없다는 것이다.
System.out.println(<Fruit>makeJuice(fruitBox));		//에러. 클래스 이름 생략 불가
System.out.println(this.<Fruit>makeJuice(fruitBox));
System.out.println(Juicer.<Fruit>makeJuice(fruitBox));
//같은 클래스 내에 있는 멤버들끼리는 참조변수나 클래스 이름, 즉 this나 클래스 이름을 생략하고 메서드 이름만으로 호출이 가능하지만
//대입된 타입이 있을 때는 반드시 써줘야 한다.
```

지네릭 메서드는 매개변수의 타입이 복잡할 때도 유용하다.     
만일 아래와 같은 코드가 있다면 타입을 별도로 선언함으로써 코드를 간략히 할 수 있다.

```java
public static void printAll(ArrayList<? extends Product> list, ArrayList<? extends Product> list2) {
	for(Unit u : list)
		System.out.println(u);		}
		//>>>>>>>>>>>>>
public static <T extends Product> void printAll(ArrayList<T> list, ArrayList<T> list2) {
	for(Unit u : list)
		System.out.println(u);		}		
```

아래의 메서드는 Collections클래스의 sort()인데, 위에서 설명한 sort()와 달리 매개변수가 하나이다.

```java
public static <T extends Comparable<? super T>> void sort ( List<T>)
//매개변수로 지정한 List<T>를 정렬한다는 것은 알겠는데, 메서드에 선언된 지네릭 타입이 복잡하다. 와일드 카드를 벗겨낸다.
public static <T extends Comparable<T> void sort(List<T>)
//List<T>의 요소가 Comparable 인터페이스를 구현한 것이어야 한다는 뜻이다.
//앞서 살펴본 것처럼 인터페이스라고 해서 implements를 쓰지 않는다.

//List<T>: 타입 T를 요소로 하는 List를 매개변수로 허용한다.
//<T extends Comparable<? super T>>: 'T'는 Comparable을 구현한 클래스이어야 하며
//(<T extends Comparable>), 'T' 또는 그 조상의 타입을 비교하는 Comparable이어야 한다는 것(Comparable<? super T>)을 의미한다.
//만일 T가 Student이고, Person의 자손이라면, <? super T>는 Student, Person, Object가 모두 가능하다.
```

## 지네릭 타입의 형변환

```java
Box box = null;
Box<Object> objBox = null;

box = (Box)objBox;		//지네릭 타입 -> 원시 타입, 가능하나 경고 발생
objBox = (Box<Object>)box;	//원시 타입 -> 지네릭 타입, 가능하나 경고 발생
```
지네릭 타입과 넌지네릭 타입간의 형변환은 항상 가능하나 경고가 발생한다.

```java
Box<Object> objBox = null;
Box<String> strBox = null;

objBox = (Box<Object>)strBox;		//에러. Box<String> -> Box<Object>
strBox = (Box<String>)objBox;		//에러. Box<Object> -> Box<String>
```
대입된 타입이 Object일지라도 불가능하다. 

```java
Box<? extends Object> wBox = new Box<String>();	//형변환이 된다.
//그래서 앞서 배운 makeJuice메서드의 매개변수에 다형성이 적용될 수 있었던 것이다.

static  Juice makeJuice(FruitBox<? extends Fruit> box)	{...}

FruitBox <? extends Fruit> box = new FruitBox<Fruit>();
FruitBox <? extends Fruit> box = new FruitBox<Apple>();
FruitBox <? extends Fruit> box = new FruitBox<Grape>();

// 반대로의 형변환도 성립하지만 확인되지 않은 형변환이라는 경고가 발생한다.
//FruitBox<? extends Fruit>에 대입될 수 있는 타입이 여러 개인데다,
//FruitBox<Apple>을 제외한 다른 타입은 FruitBox<Apple>로 형변환될 수 없기 때문이다.
FruitBox<? extends Fruit> box = null;
FruitBox<Apple> appleBox = (FruitBox<Apple>)box;		//가능하나 미확인 타입으로 형변환 경고
```



다음은 java.util.Optional클래스의 실제 소스의 일부이다.

```java
public final class Optional <T> {
	private static final Optional<?> EMPTY = new Optional<>();
	private final T value;
		...
	public static<T> Optional<T> empty() {
		Optional<T> t = (<Optional<T>) EMPTY;
		return t;	}	...	}
```
static상수 EMPTY에 비어있는 Optional객체를 생성해서 저장했다가 empty()를 호출하면 EMPTY를 형변환해서 반환한다.       
상수를 선언하는 문장을 단계별로 분석하면 다음과 같다.

```java
Optional<?> EMPTY = new Optional<>();
Optional<? extends Object> EMPTY = new Optional<>();
Optional<? extends Object> EMPTY = new Optional<Object>();
//<?>는 <? extends Object>를 줄여 쓴 것이며, <>안에 생략된 타입은 Object이다.

Optional<?> EMPTY = new Optional<?>();		//에러. 미확인 타입의 객체는 생성 불가.
Optional<?> EMPTY = new Optional<Object>();	//가능
Optional<?> EMPTY = new Optional<>();		//위 문장과 동일
//class Box<T extends Fruit>의 경우 Box<?> b = new Box<>;는 Box<?> b = new Box<Fruit>;이다.

//위 문장에서 EMPTY의 타입을 Optional<Object>가 아닌 Optional<?>로 한 이유는 Optional<T>로 형변환이 가능하기 때문이다.
Optional<?> wopt = new Optional<Object>();
Optional<Object> oopt = new Optional<Object>();

Optional<String> sopt = (Optional<String>)wopt;	//가능. 형변환 가능
Optional<String> sopt = (Optaonal<String>)oopt;	//에러. 형변환 불가능

//empty의 타입이 Optional<T>이므로 EMPTY를 Optional<T>로 형변환해야 하는데,
//위의 코드에서 알 수 있는 것처럼 Optional<Object>는 Optional<T>로 형변환이 불가능하다.

public static<T> Optional<T> empty() {
	Optional<T> t = (Optional<T>) EMPTY;	//Optional<?> -> Optional<T>
	return t;			}

//정리하면, Optional<Object>를 Optional<String>으로 직접 형변환하는 것은 불가능하지만,
//와일드 카드가 포함된 지네릭 타입으로 형변환하면 가능하다. 대신 확인되지 않은 타입으로의 형변환이라는 경고가 발생한다.
Optional<Object> -> Object<T>		//형변환 불가능.
Optional<Object> -> Object<?> -> Object<T>		//형변환 가능. 경고 발생

//마지막으로 와일드 카드가 사용된 지네릭 타입끼리도 다음과 같은 경우에는 형변환이 가능하다.
FruitBox<? extends Object> objBox = null;
FruitBox<? extends String> strBox = null;

strBox = (FruitBox<? extends String>)objBox;		//가능. 미확정 타입으로 형변환 경고
objBox = (FruitBox<? extends Object>)strBox;		//가능. 미확정 타입으로 형변환 경고

//형변환이 가능하긴 하지만, 와일드 카드는 타입이 확정된 타입이 아니므로 컴파일러는 미확정 타입으로 형변환하는 것이라고 경고한다.
```

## 지네릭 타입의 제거

컴파일러는 지네릭 타입을 이용해서 소스파일을 체크하고, 필요한 곳에는 형변환을 넣어준다. 그리고 지네릭 타입을 제거한다.     
즉, 컴파일된 파일에는 지네릭 타입에 대한 정보가 없는 것이다.    

1. 지네릭 타입의 경계bound를 제거한다.     

> 지네릭 타입이 < T extends Fruit >라면 T는 Fruit로 치환된다.      
> < T >인 경우는 T는 Object로 치환된다. 그리고 클래스 옆의 선언은 제거된다.      

```java
class Box <T extends Fruit> {
	void add(T t) { ... }		}
//>>>>>>>>>>>>
class Box {
	void add(Fruit t) { ... }	}
```

2. 지네릭 타입을 제거한 후에 타입이 일치하지 않으면, 형변환을 추가한다.     

> List의 get()은 Object타입을 반환하므로 형변환이 필요하다.

```java
T get(int i) {
	return list.get(i);	}
//>>>>>>>>>>>>>>>
Fruit get(int i) {
	return (Fruit)list.get(i);		}
```
> 와일드 카드가 포함되어 있는 경우에는 다음과 같이 적절한 타입으로의 형변환이 추가된다.

```java
static Juice makrJuice(FruitBox<? extends Fruit> box) {
	Strung tmp = "";
	for(Fruit f : box.getList())	tmp += f + " ";
	return new Juice(tmp);		}
//>>>>>>>>>>>>>>>>
static Juice makeJuice(FruitBox box)	{
	String tmp = "";
	Iterator it = box.getList().iterator();
	while(it.hasNext())	{
		tmp += (Fruit)it.next() + " ";		}
	return new Juice(tmp);		}
```
# 열거형 enums

## 열거형 이란?

열거형은 서로 관련된 상수를 편리하게 선언하기 위 한 것으로 여러 상수를 정의할 때 사용하면 유용하다.       
열거형이 갖는 값뿐만 아니라 타입도 관리하기 때문에 보다 논리적인 오류를 줄일 수 있다.   

```java
class Card {
	static final int CLOVER = 0;
	static final int HEART = 1;
	static final int DIAMOND = 2;
	static final int SPADE = 3;
	
	static final int TWO = 0;
	static final int THREE = 1;
	static final int FOUR = 2;
	
	final int kind;
	final int num;		}
//>>>>>>>>>>>>>>>>>>>>>>>>
class card {
	enum Kind {CLOVER, HEART, DIAMOND, SPADE}	//열거형 Kind를 정의
	enum Value{TWO, THREE, FOUR}				//열거형 VALUE를 정의
	
	final Kind kind;	//타입이 int가 아니라 Kind다.
	final Value value;
```

자바의 열거형은 '타입에 안전한 열거형typesafe enum이라서 실제 값이 같아도 타입이 다르면 컴파일 에러가 발생한다.      
이처럼 값뿐만 아니라 타입까지 체크하기 떄문에 타입에 안전하다고 하는 것이다.

```java
if(Card.CLOVER == Card.TWO)		//true지만 false이어야 의미상 맞음.
if(Card.Kind.CLOVER == Card.Value.TWO)	//컴파일 에러. 값은 같지만 타입이 다름
```

그리고 상수의 값이 바뀌면, 해당 상수를 참조하는 모든 소스를 다시 컴파일해야 한다.     
하지만 열거형 상수를 사용하면, 기존의 소스를 다시 컴파일하지 않아도 된다.

## 열거형의 정의와 사용

* enum 열거형이름 { 상수명1, 상수명2, ...}     
예를 들어 동서남북 4방향을 상수로 정의하는 열거형은 다음과 같다.

```java
enum Direction { EATE, SOUTH, WEST, NORTH }
```

이 열거형에 정의된 상수를 사용하는 방법은 '열거형이름.상수명'이다.           
클래스의 static 변수를 참조하는 것과 동일하다.

```java
class Unit {
	int x, y;			//유닛의 위치
	Direction dir;		//열거형을 인스턴스 변수로 선언
	
	void init(){
		dir = Direction.EAST;	//유닛의 방향을 EAST로 초기화
	}		}
```

열거형 상수간의 비교에는 '=='를 사용할 수 있다. equals()가 아닌 '=='로 비교가 가능하다는 것은 빠른 성능을 제공한다는 얘기다.     
그러나 < , > 와 같은 비교연산자는 사용할 수 없고 compareTo()는 사용가능하다.     

```java
if(dir == Direction.EAST) {
	x++;
} else if(dir > Direction.EAST) {	//에러. 열거형 상수에 비교연산자 사용불가
	...
  else if(dir.compareTo(Direction.WEST)>0) { //compareTo()는 가능.
  ...
```

다음과 같이 switch문의 조건식에도 열거형을 사용할 수 있다.

```java
void move() {
	switch(dir) {
		case EAST: x++;	//Direction.EAST라고 쓰면 안된다.
			break;
		case WEST: x--;
			break;
		case SOUTH: y++;
			break;
		case NORTH; y--;
			break;
	}	}
```

case문에 열거형의 이름은 적지 않고 상수의 이름만 적어야 한다는 제약이 있다.

#### 모든 열거형의 조상-java.lang.Enum

열거형 Direction에 정의된 모든 상수를 출력하려면, 다음과 같이 한다.

```java
Direction[] dArr = Direction.values();

for(Direction d : dArr)	//for(Direction  : Direction.values())
System.out.printf("%s = %d%n", d.name(), d.ordinal());
```

values()는 열거형의 모든 상수를 배열에 담아 반환한다.     
이 메서드는 모든 열거형이 가지고 있는 것으로 컴파일러가 자동으로 추가해준다.      
ordinal()은 모든 열거형의 조상인 java.lang.Enum클래스에 정의된 것으로, 열거형 상수가 정의된 순서를 정수로 반환한다.     
Enum클래스에는 다음과 같은 메서드가 정의되어 있다.

```java
Class<E> getDeclaringClass()
//열거형의 class객체를 반환한다.
String name()
//열거형 상수의 이름을 문자열로 반환한다.
int ordinal()
//열거형 상수가 정의된 순서를 반환한다.0부터 시작
T valueOf(Class<T> enumType, String name)
//지정된 열거형에서 name과 일치하는 열거형 상수를 반환한다.
```

이 외에도 values()처럼 컴파일러가 자동으로 추가해주는 메서드가 하나 더 있다.

```java
static E values()
static E valueOf(String name)
//이 메서드는 열거형 상수의 이름으로 문자열 상수에 대한 참조를 얻을 수 있게 해준다.

Direction d = Direction.valueOf("WEST");
System.out.println(d);		//WEST
System.out.println(Direction.WEST == Direction.valueOf("WEST"));		//true
```

```java
enum Direction { EAST, WEST, SOUTH, NORTH}

public class EnumEx1 {

	public static void main(String[] args) {
		Direction d1 = Direction.EAST;
		Direction d2 = Direction.valueOf("WEST");
		Direction d3 = Direction.valueOf(Direction.class, "EAST");
		
		System.out.println(d1);			//EAST
		System.out.println(d2);			//WEST
		System.out.println(d3);			//EAST
		
		System.out.println(d1 == d2);	//false
		System.out.println(d1 == d3);	//true
		System.out.println(d1.equals(d3));	//true
//		System.out.println(d1 > d3);	//에러
		System.out.println(d1.compareTo(d3));	//0
		System.out.println(d1.compareTo(d2));	//-1
		
		switch(d1) {		//The direction is EAST.
		case EAST:	//Direction.EAST라고 쓸 수 없다.
			System.out.println("The direction is EAST.");
			break;
		case WEST:
			System.out.println("The direction is WEST.");
			break;
		case SOUTH:
			System.out.println("The direction is SOUTH.");
			break;
		case NORTH:
			System.out.println("The direction is NORTH.");
			break;
		}
		
		Direction[] dArr = Direction.values();
		
		for(Direction d : dArr)			//for(Direction d : Direction.values())
			System.out.printf("%s = %d%n", d.name(), d.ordinal());
		//EAST = 0	WEST = 1	SOUTH = 2	NORTH = 3
	}
}
```

## 열거형에 멤버 추가하기

Enum클래스에 정의된 ordinal()이 열거형 상수가 정의된 순서를 반환하지만,       
이 값은 내부적인 용도로만 사용되기 위한 것이므로 열거형 상수의 값으로 사용하지 않는 것이 좋다.     
열거형 상수의 값이 불연속적인 경우에는 열거형 상수의 이름 옆에 원하는 값을 괄호로 넣어주면 된다.

```java
enum Direction { EAST(1), WEST(2), SOUTH(3), NORTH(4)}
```

그리고 지정된 값을 저장할 수 있는 인스턴스 변수와 생성자를 새로 추가해 주어야 한다.     
열거형 상수를 모두 정의한 다음 다른 멤버들을 추가해야하고, 열거형 상수의 마지막에 ; 을 넣어야 한다.

```java
enum Direction {
	EAST(1), SOUTH(5), WEST(-1), NORTH(10);	//끝에 ;을 추가해야 한다.
	
	private final int value;	//정수를 저장할 필드(인스턴스 필드)를 추가
	Direction(int value)	{this.value = value)	//생성자 추가
	
	public getValue()	{return value;}	}
```

열거형의 인스턴스 변수는 반드시 final이어야 한다는 제약은 없지만,     
value는 열거형 상수의 값을 저장하기 위한 것이므로 final을 붙였다.     
그리고 외부에서 이 값을 얻을 수 있게 getValue()도 추가하였다.

```java
Direction d = new Direction(1);		//에러. 열거형의 생성자는 외부에서 호출불가
```

열거형 Direction에 새로운 생성자가 추가되었지만,      
위와 같이 열거형의 객체를 생성할 수 없다. 열거형의 생성자는 제어자가 묵시적으로 private이기 때문이다.

```java
enum Direction {
	...
	Direction(int value) {		//private Direction(int value)와 동일
		...		}
```

다음과 같이 하나의 열거형 상수에 여러 값을 지정할 수도 있지만,     
그에 맞게 인스턴스 변수와 생성자 등을 새로 추가해주어야 한다.   

```java
enum Direction {
	EAST(1, ">"), SOUTH(2, "V"), WEST(3, "<"), NORTH(4, "^");
	
	private final int value;
	private final String symbol;
	
	Direction(int value, String symbol)	{	//접근 제어자 private이 생략됨
		this.value = value;
		this.symbol = symbol;
	}
	public int getValue()	{return value;}
	public String getSymbol()	{return symbol;}
```

```java
enum Direction {
	EAST(1, ">"), SOUTH(2, "V"), WEST(3, "<"), NORTH(4, "^");
	
	private static final Direction[] DIR_ARR = Direction.values();
	private final int value;
	private final String symbol;
	
	Direction(int value, String symbol)	{	//접근 제어자 private이 생략됨
		this.value = value;
		this.symbol = symbol;
	}
	public int getValue()	{return value;}
	public String getSymbol()	{return symbol;}
	
	public static Direction of(int dir) {
		if(dir<1 || dir>4)
			throw new IllegalArgumentException("Invalid value : "+ dir);
		
		return DIR_ARR[dir-1];
	}
	//방향을 회전시키는 메서드. num의 값만큼 90도씩 시계방향으로 회전한다.
	public Direction rotate(int num) {
		num = num%4;
		
		if(num<0) num +=4;	//num이 음수일 때는 시계반대 방향으로 회전
		
		return DIR_ARR[(value-1+num)%4];
	}
	public String toString() {
		return name() + getSymbol();
	}
}

public class EnumEx2 {
	public static void main(String[] args) {
		for(Direction d : Direction.values())
			System.out.printf("%s = %d%n", d.name(), d.ordinal());
			//EAST = 0	SOUTH = 1	WEST = 2	NORTH = 3
		
		Direction d1 = Direction.EAST;
		Direction d2 = Direction.of(1);

		System.out.printf("%s = %d%n", d1.name(), d1.ordinal());	//EAST=0
		System.out.printf("%s = %d%n", d2.name(), d2.ordinal());	//EAST=0
		
		System.out.println(Direction.EAST.rotate(1));	//SOUTHV
		System.out.println(Direction.EAST.rotate(2));	//WEST<
		System.out.println(Direction.EAST.rotate(-1));	//NORTH^
		System.out.println(Direction.EAST.rotate(-2));	//WEST<
	}
}
```

## 열거형에 추상 메서드 추가하기

열거형 Transportation은 운송 수단의 종류 별로 상수를 정의하고 있으며,      
각 운송 수단에는 기본요금이 책정되어 있다.

```java
enum Transportation {
	BUS(100), TRAIN(150), SHIP(100), AIRPLANE(300);
	
	private final int BASIC_FARE;
	
	private Transportation(int basicFare)	{
		BASIC_FARE = basicFare;
	}
	int fare()	{	//운송 요금을 반환
		return BASIC_FARE;	}	}
```
거리에 따라 요금을 계산하는 방식이 각 운송 수단마다 다를 것이기 때문에    
열거형에 추상 메서드 fare(int distance)를 선언하고 각 열거형 상수가 이 추상 메서드를 구현하도록 한다.

```java
enum Transportation	{
	BUS(100)		{
		int fare(int distance) {return distance*BASIC_FARE};			},
	TRAIN(150)	{int fare(int distance) {return distance*BASIC_FARE};	},
	SHIP(100)	{int fare(int distance) {return distance*BASIC_FARE};	},
	AIRPLANE(300){int fare(int distance) {return distance*BASIC_FARE};	}};

	abstract int fare(int distance);	//거리에 따른 요금을 계산하는 추상 메서드
	protected final int BASIC_FARE;		//protected로 해야 각 상수에서 접근가능
	Transportation(int basicFare)	{
		BASIC_FARE = basicFare;
	}
	public int getBasicFare()	{return BASIC_FARE;	}
}
```

위 코드는 열거형에 정의된 추상 메서드를 각 상수가 어떻게 구현하는지 보여준다.      
익명클래스와 유사하다.

```java
enum Transportation	{
	BUS(100)	{int fare(int distance) {return distance*BASIC_FARE;}	},
	TRAIN(150)	{int fare(int distance) {return distance*BASIC_FARE;}	},
	SHIP(100)	{int fare(int distance) {return distance*BASIC_FARE;}	},
	AIRPLANE(300)	{int fare(int distance) {return distance*BASIC_FARE;}	};
	
	protected final int BASIC_FARE;	//protected로 해야 각 상수에서 접근 가능
	
	Transportation(int basicFare)	{	//private Transportation(int basicFare)
		BASIC_FARE = basicFare;
	}
	public int getBasicFare()	{	return BASIC_FARE;	}
	 
	abstract int fare(int distance);	//거리에 따른 요금 계산

}

public class EnumEx3 {

	public static void main(String[] args) {
		System.out.println(Transportation.BUS.fare(100));		//10000
		System.out.println(Transportation.TRAIN.fare(100));		//15000
		System.out.println(Transportation.SHIP.fare(100));		//10000
		System.out.println(Transportation.AIRPLANE.fare(100));	//30000
	}
}
```

## 열거형의 이해

```java
enum Direction	{	EAST, SOUTH, WEST, NORTH	}
//열거형 상수 하나하나가 Direction객체다. 위 문장을 클래스로 정의한다면 아래와 같다.

class Direction	{
	static final Direction EAST = new Direction("EAST");
	static final Direction SOUTH = new Direction("SOUTH");
	static final Direction WEST = new Direction("WEST");
	static final Direction NORTH = new Direction("NORTH");
	
	private String name;
	
	private Direction(String name)	{
		this.name = name;
	}
}
```

Direction클래스의 static상수 EAST, SOUTH, WEST, NORTH의 값은 객체의 주소이고,     
이 값은 바뀌지 않는 값이므로 '=='로 비교가 가능한 것이다.        
모든 열거형은 추상 클래스 Enum의 자손이므로, Enum을 흉내 내어 MyEnum을 작성하면 다음과 같다.

```java
abstract class MyEnum<T extends MyEnum<T>> implements Comparable<T>	{
	static int id = 0;	//객체에 붙일 일련번호 0부터 시작
	
	int ordinal;
	String name = "";
	
	public int ordinal()	{return ordinal;}
	
	MyEnum(String name)	{
		this.name = name;
		ordinal = id++;	//객체를 생성할 때마다 id의 값을 증가시킨다.
	}
	
	public int compareTo(T t)	{
		return ordinal - t.ordinal();
	}
}
```

앞서 배운 것과 같이 객체가 생성될 때마다 번호를 붙여서 인스턴스변수 ordinal에 저장한다.     
그리고 Comparable인터페이스를 구현해서 열거형 상수간의 비교가 가능하도록 되어 있다.     
클래스를 MyEnum< T >와 같이 선언하였다면 타입 T에 ordinal()이 정의되어 있는지 확인할 수 없어,    
compareTo()를 위와 같이 간단하게 작성할 수 없었을 것이다.    
그래서 MyEnum < T extends < MyEnum < T > >와 같이 선언한 것이며,     
이것은 타입 T가 MyEnum< T >의 자손이어야 한다는 의미이다.     
그리고 추상 메서드를 새로 추가하면, 클래스 앞에도 abstract를 붙여줘야 하고,     
각 static상수들도 추상 메서드를 구현해주어야 한다.     
아래의 코드에서는 익명 클래스의 형태로 추상 메서드를 구현하였다.

```java
abstract class Direction extends MyEnum	{
	static final Direction EAST = new Direction("EAST");	{
		point move(Point p) {...}
	};
	static final Direction SOUTH = new Direction("SOUTH");	{
		point move(Point p) {...}
	};
	static final Direction WEST = new Direction("WEST");	{
		point move(Point p) {...}
	};
	static final Direction NORTH = new Direction("NORTH");	{
		point move(Point p) {...}
	};
	private String name;
	
	private Direction(String name) {
		this.name = name;
	}
	
	abstract Point move(Point p);
}
```
```java
abstract class MyEnum<T extends MyEnum<T>> implements Comparable<T>	{
	static int id = 0;
	int ordinal;
	String name = "";
	
	public int ordinal()	{	return ordinal;	}
	
	MyEnum(String name)	{
		this.name = name;
		ordinal = id++;
	}
	public int compareTo(T t) {
		return ordinal - t.ordinal;
	}
}
abstract class MyTransportation extends MyEnum	{
	static final MyTransportation BUS = new MyTransportation("BUS", 100) {
		int fare(int distance)	{	return distance*BASIC_FARE;	}	};
	static final MyTransportation TRAIN = new MyTransportation("TRAIN", 150) {
		int fare(int distance)	{	return distance*BASIC_FARE;	}	};
	static final MyTransportation SHIP = new MyTransportation("SHIP", 100) {
		int fare(int distance)	{	return distance*BASIC_FARE;	}	};
	static final MyTransportation AIRPLANE = new MyTransportation("AIRPLANE", 300) {
		int fare(int distance)	{	return distance*BASIC_FARE;	}	};
		
		abstract int fare(int distance);	//추상 메서드
		
		protected final int BASIC_FARE;
		
		private MyTransportation(String name, int basicFare)	{
			super(name);
			BASIC_FARE = basicFare;
		}
		
		public String name()	{	return name;	}
		public String toString()	{	return name;	}
}

public class EnumEx4 {

	public static void main(String[] args) {
		MyTransportation t1 = MyTransportation.BUS;
		MyTransportation t2 = MyTransportation.BUS;
		MyTransportation t3 = MyTransportation.TRAIN;
		MyTransportation t4 = MyTransportation.SHIP;
		MyTransportation t5 = MyTransportation.AIRPLANE;
		
		System.out.println(t1.name +":"+ t1.ordinal());		//BUS:0
		System.out.println(t2.name +":"+ t2.ordinal());		//BUS:0
		System.out.println(t3.name +":"+ t3.ordinal());		//TRAIN:1
		System.out.println(t4.name +":"+ t4.ordinal());		//SHIP:2
		System.out.println(t5.name +":"+ t5.ordinal());		//AIRPLANE:3
		System.out.println(t1==t2);							//true
		System.out.println(t1.compareTo(t3));				//-1
	}
}
```
# 애너테이션 annotation

## 애너테이션 이란?

 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 애너테이션이다.     
 애너테이션은 주석처럼 프로그래밍 언어애 영향을 미치지 않으면서도 다른 프로그램애게 유용한 정보를 제공할 수 있다.      
 
 ```java
 @Test		//이 메서드가 테스트 대상임을 테스트 프로그램에게 알린다.
 			//프로그램 자체에는 아무런 영향을 미치지 않는다.
 public void method()	{ ... }
 ```
 
JDK애서 제공하는 표준 애너테이션은 주로 컴파일러를 위한 것으로 컴파일러에게 유용한 정보를 제공한다.     
그리고 새로운 애너테이션을 정의할 때 사용하는 메타 애너테이션을 제공한다.     
JDK에서 제공하는 애너테이션은 java.lang.annotation패키지에 포함되어 있다.
 
## 표준 애너테이션
 
자바에서 기본적으로 제공하는 애너테이션은 몇 개 없고,      
그 중 일부는 메타 애너테이션으로 애너테이션을 정의하는데 사용되는 애너테이션의 애너테이션이다.     
 
 ```java
 @Overrids
 //컴파일러에게 오버라이딩하는 메서드라는 것을 알린다.
 @Deprecated
 //앞으로 사용하지 않을 것을 권장하는 대상에 붙인다.
 @SuppressWarnings
 //컴파일러의 특정 경고메시지가 나타나지 않게 해준다.
 @SafeVarargs
 //지네릭스 타입의 가변인자에 사용한다.
 @FunctionalInterface
 //함수형 인터페이스라는 것을 알린다.
 @Native
 //native메서드에서 참조되는 상수 앞에 붙인다.
 
 //메타 애너테이션
 @Target
 //애너테이션이 적용가능한 대상을 지정하는데 사용한다.
 @Documented
 //애너테이션 정보가 javadoc으로 작성된 문서에 포함되게 한다.
 @Inherited
 //애너테이션이 자손 클래스에 상속되도록 한다.
 @Retention
 //애너테이션이 유지되는 범위를 지정하는데 사용한다.
 @Repeatable
 //애너테이션을 반복해서 적용할 수 있게 한다.
 ```
 
#### @Override

메서드 앞에만 붙일 수 있는 애너테이션으로, 조상의 메서드를 오버라딩하는 것이라는 걸 컴파일러에게 알려준다.       
오버라이딩하며 메서드의 이름을 잘못 적는 등의 실수가 있을 때 에러메시지를 출력한다.     

#### @Deprecated

더 이상 사용되지 않는 필드나 메서드에 붙인다.      
이 애너테이션이 붙은 대상은 다른 것으로 대체되었으니 더 이상 사용하지 않을 것을 권한다는 의미이다.     

#### @FunctionalInterface

함수형 인터페이스를 선언할 때, 이 애너테이션을 붙이면 컴파일러가 함수형 인터페이스를 올바르게 선언했는지 확인하고,      
잘못된 경우 에러를 발생시킨다. 필수는 아니지만 실수를 방지할 수 있다.     

#### @SuppressWarnings

컴파일러가 보여주는 경고메시지가 나타나지 않게 억제해준다.     
주로 사용되는 경고 메시지 종류는 drprecation, unchecked, rawtypes, varargs 정도 이다.     
deprecation은 @Deprecated가 붙은 대상을 사용해서 발생하는 경고를,     
unchecked는 지네릭스로 타입을 지정하지 않았을 때 발생하는 경고를,     
rawtypes는 지네릭스를 사용하지 않아서 발생하는 경고를,     
varargs는 가변인자의 타입이 지네릭 타입일 때 발생하는 경고를 억제할 때 사용된다.     
억제하려는 경고 메시지를 애너테이션의 뒤에 괄호()안에 문자열로 지정하면 된다.

```java
@SuppressWarnings("unchecked")		//지네릭스와 관련된 경고를 억제
ArrayList list = new ArrayList();	//지네릭 타입을 지정하지 않았음.
list.add(obj);						//여기서 경고가 발생.

//만약 둘 이상의 경고를 동시에 억제하려면 배열처럼 괄호{}를 추가로 사용한다.
@SuppressWarnings({"deprecation", "unchecked", "varargs"})
```

```java
class NewClass{
	int newField;
	
	int getNewField() {
		return newField;
	}
	@Deprecated
	int oldField;
	
	@Deprecated
	int getOldField() {
		return oldField;
	}
}
public class AnnotationEx3 {
	@SuppressWarnings("deprecation")		//deprecation관련 경고 억제
	public static void main(String[] args) {
		NewClass nc = new NewClass();
		
		nc.oldField = 10;					//@Deprecated가 붙은 대상을 사용.
		System.out.println(nc.getOldField()); //@Deprecated가 붙은 대상을 사용.
		
		@SuppressWarnings("unchecked")				//지네릭 관련 경고를 억제
		ArrayList<NewClass> list = new ArrayList();	//타입을 지정하지 않음.
		list.add(nc);	
	}
}
```

main 메서드 앞에 @SuppressWarnings({"deprecation", "unchecked"})로 바꿔서     
두 종류의 경고를 모두 억제할 수도 있지만 이렇게 한다면      
나중에 추가된 코드에서 발생할 수 있는 경고까지 억제할 수 있으므로 바람직하지 않다.      
해당 대상에만 애너테이션을 붙여서 경고의 억제범위를 최소화하는 것이 좋다.

#### @SafeVarargs
메서드에 선언된 가변인자의 타입이 non-reifiable타입일 경우,       
해당 메서드를 선언하는 부분과 호출하는 부분에서 "unchecked"경고가 발생한다.    
해당 코드에 문제가 없다면 @SageVarargs를 사용해서 경고를 억제하여야 한다.               
이 애너테이션은 static이나 final이 붙은 메서드와 생성자에만 붙일 수 있다.     
즉, 오버라이딩될 수 있는 메서드에는 사용할 수 없다.    
지네릭스에서 컴파일 후에도 제거되지 않는 타입을 reifiable타입이라고 하고, 제거되는 타입을 non-reifialbe타입이라고 한다.     
지네릭 타입들은 대부분 컴파일 시에 제거되므로 non-reifialbe타입이다.



예를 들어, java.util.Arrays의 asList()는 다음과 같이 정의되어 있으며,    
이 메서드는 매개변수로 넘겨받은 값들로 배열을 만들어서 새로운 ArrayList객체를 만들어서 반환하는데 이 과정에서 경고가 발생한다.

```java
public static <T> List<T> asList(T...a)	{
	return new ArrayList<T>(a);	//ArrayList(E[] array)를 호출. 경고 발생
//이 ArrayList는 Arrays클래스의 내부 클래스다. java.util.ArrayList가 아니다.
```

asList()의 매개변수가 가변인자인 동시에 지네릭 타입이다.    
메서드에 선언된 타입T는 컴파일 과정에서 Object로 바뀐다. 즉, Object[]가 되는 것이다.     
Object[]에는 모든 타입의 객체가 들어올 수 있으므로, 이 배열로 ArrayList< T >를 생성하는 것은 위험하다고 경고하는 것이다.     
그러나 asList()가 호출되는 부분을 컴파일러가 체크해서 타입T가 아닌 다른 타입이 들어가지 못하게 할 것이므로 위 코드는 문제가 없다.    
이럴때 메서드 앞에 @SafeVarargs를 붙여서 이 메서드의 가변인자는 타입 안정성이 있다고 컴파일러에 알려 경고가 발생하지않게 해야한다.     
메서드를 선언할 때 @SafeVarargs를 붙이면 이 메서드를 호출하는 곳에서 발생하는 경고도 억제된다.     
반면 @SafeVarargs대신, @SuppressWarnings("unchecked")로 경고를 억제하려면, 메서드 선언부와 호출부 모두에 붙여야한다.    
그리고 @SafeVarargs로 unchecked경고는 억제할 수 있지만 varargs경고는 억제할 수 없어 습관적으로 같이 붙인다.    

```java
@SageVarargs		//unchecked경고를 억제한다.
@SuppressWarnings("varargs")	//varargs경고를 억제한다.
public static <T> List<T> asList(T...a)	{
	return new ArrayList<>(a);
}
```

@SuppressWarnings("varargs")를 붙이지 않아도 경고없이 컴파일이 되지만     
-Xlint옵션을 붙여서 컴파일해보면 varargs경고가 발생한다는 것을 알 수 있다.     
그러므로 가능하면 이 두 애너테이션을 항상 같이 사용하는 것이 좋다.

```java
class MyArrayList<T> {
	T[] arr;
	
	@SafeVarargs
	@SuppressWarnings("varargs")
	MyArrayList(T...arr){
		this.arr = arr;
	}
	@SafeVarargs
	//@SuppressWarnings("unchecked")
	public static <T> MyArrayList<T> asList(T...a){
		return new MyArrayList<>(a);
	}
	public String toString() {
		return Arrays.toString(arr);
	}
}
public class AnnotationEx4 {
	//@SupressWarnings("unchecked")
	public static void main(String[] args) {
		MyArrayList<String> list = MyArrayList.asList("1", "2", "3");
		
		System.out.println(list);
	}
}
```
옵션없이 컴파일했을 때는 아무런 경고가 없지만, -Xlint옵션을 붙여서 컴파일했을 때는 varargs경고가 발생한다.     
아래와 같이 애너테이션을 추가하면 -Xlint옵션으로 컴파일 하여도 경고가 나타나지 않을 것이다.

```java
@SafeVarargs
@SuppressWarnings("varargs")	//애너테이션을 추가
//@SuppressWarnings("unchecked")
public static <T> MyArrayList<T> asList(T...a) {
	return new MyArrayList<>(a);
}
```

그리고 예제에서 asList()의 @SafeVarargs를 주석처리하고, asList()와 main()에 붙은 @SuppressWarings("unchecked")를 주석해제한다면      
@SafeVarargs가 이 두 개의 애너테이션과 같은 효과를 얻는다는 것을 확인할 수 있다.

## 메타 애너테이션

메타 애너테이션은 애너테이션을 위한 애너테이션, 즉 애너테이션에 붙이는 애너테이션으로            
애너테이션을 정의할 때 애너테이션의 적용대상이나 유지기간 등을 지정하는데 사용된다.       

#### @Target
애너테이션을 적용가능한 대상을 지정하는데 사용된다.     
아래는 @SurppressWarnings를 정의한 것인데 이 애너테이션에 적용할 수 있는 대상을 @Target으로 지정하였다.

```java
@Targeet({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SurppressWarnings {
	String[] value();
}
```
@Target으로 지정할 수 있는 애너테이션 적용대상의 종류는 아래와 같다.

ANNOTATION_TYPE : 애너테이션       
CONSTRUCTOR : 생성자            
FIELD : 필드(멤버변수, enum상수)                      
LOCAL_VARIABLE : 지역변수                    
METHOD : 메서드               
PACKAGE : 패키지                  
PARAMETER : 매개변수          
TYPE : 타입(클래스, 인터페이스  , enum)                         
TYPE_PARAMETER : 타입 매개변수                             
TYPE_USE : 타입이 사용되는 모든 곳                        


TYPE은 타입을 선언할 때, 애너테이션을 붙일 수 있다는 뜻이고,            
TYPE_USE는 해당 타입의 변수를 선언할 때 붙일 수 있다는 뜻이다.
위 값들은 java.lang.annotation.ElementType이라는 열거형에 정의되어 있으며,     
아래와 같이 static import문을 쓰면 ElementType.TYPE을 TYPE과 같이 간단히 할 수 있다.

```java
import static java.lang.annotation.ElementType.*;

@Target({FIELD, TYPE, TYPE_USE})		//적용대상이 FIELD, TYPE, TYPE_USE
public @interface MyAnnotation { }		//MyAnnotation

@MyAnnotation	//적용 대상이 TYPE인 경우
class MyClass {
	@MyAnnotation	//적용 대상이 FIELD인 경우
	int i;
	
	@MyAnnotation	//적용 대상이 TYPE_USE인 경우
	MyClass mc;
```

FIELD는 기본형에, TYPE_USE는 참조형에 사용된다.

#### @Retention

애너테이션이 유지되는 기간을 지정하는데 사용된다.            
애녀테이션의 유지 정책의 종류는 다음과 같다.
SOURCE : 소스 파일에만 존재. 클래스파일에는 존재하지 않음.     
CLASS : 클래스 파일에 존재. 실행시에 사용불가. 기본값      
RUNTIME : 클래스 파일에 존재. 실행시에 사용가능.



@Override나 @SuppressWarnings처럼 컴파일러가 사용하는 애너테이션은 유지 정책이 SOURCE다.    
컴파일러를 직접 작성할 것이 아니면, 이 유지정책은 필요없다.

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override{ }
```

유지 정책을 RUNTIME으로 하면, 실행 시에 리플랙션reflection을 통해           
클래스 파일에 저장된 애너테이션의 정보를 읽어서 처리할 수 있다.     
@FunctionalInterface는 @Override처럼 컴파일러가 체크해주는 에너이션이지만,    
실행 시에도 사용되므로 유지정책이 RUNTIME으로 되어있다.

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface FuntionalInterFace{ }
```
유지 정책 CLASS는 컴파일러가 애너테이션의 정보를 클래스 파일에 저장할 수 있게 하지만,     
클래스 파일이 JVM에 로딩될 때는 애너테이션의 정보가 무시되어 실행 시에 애너테이션에 대한 정보를 얻을 수 없다.

#### @Documented
애너테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 한다.    
자바에서 제공하는 기본 애너테이션 중에 @Override와 @SuppressWarnings를 제외하고는 모두 이 메타 애너테이션이 붙어있다.

```java
@Documented
@Retention (RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface FunctionalInterface{ }
```

#### @Inherited
애너테이션이 자손 클래스에 상속되도록 한다.    
@Inherited가 붙은 애너테이션을 조상 클래스에 붙이면, 자손 클래스도 이 애너테이션이 붙은 것과 같이 인식된다.

```java
@Inherited			//@SupperAnno가 자손까지 영향 미치게 한다.
@interface SupperAnno

@SupperAnno
class Parent{}

class child extends Parent{}	//Child에 애너테이션이 붙은 것으로 인식
```

#### @Repeatable

보통은 하나의 대상에 한 종류의 애너테이션을 붙이는데 @Repeatable이 붙은 애너테이션은 여러 번 붙일 수 있다.

```java
@Repeatable(ToDos.class)	//ToDo애너테이션을 여러 번 반복해서 쓸 수 있게 한다.
@interface ToDo {
	String value();
}
//위와 같이 @ToDo라는 애너테이션이 정의되어 있을 때 다음과 같이 MyClass클래스에 @ToDo를 여러 번 붙이는 것이 가능하다.

@ToDo("delete test codes")
@ToDo("override inherited methods")
class MyClass { ... }
```

일반적인 애너테이션과 달리 같은 이름의 애너테이션이 여러 개가 하나의 대상에 적용될 수 있기 때문에,      
이 애너테이션들을 하나로 묶어서 다룰 수 있는 애너테이션도 추가로 정의해야 한다.

```java
@interface ToDos {	//여러 개의 ToDo애너테이션을 담을 컨테이너 애너테이션 ToDos
	ToDo[] value();	//ToDo애너테이션 배열타입의 요소를 선언. 이름이 반드시 value이어야 함.
}

@Repeatable(ToDos.class)	//괄호 안에 컨테이너 애너테이션을 지정해 주어야 한다.
@interface ToDo {
	String value();
}
```

#### Native

네이티브 메서드에 의해 참조되는 상수 필드에 정붙이는 애너테이션이다.    
네이티브 메서드는 JVM이 설치된 OS의 메서드를 말한다.           
네이티브 메서드는 보통 C언어로 작성되어 있는데, 자바에서는 메서드의 선언부만 정의하고 구현은 하지 않는다.      
그래서 추상 메서드처럼 선언부만 있고 몸통은 없다.

```java
public class Object {
	private static native void registerNatives();	//네이티브 메서드
	static {
		registerNatives();		//네이티브 메서드 호출
	}
	protected native Object clone() throws CloneNotSupportedException;
	public final native Class<?> getClass();
	public final native void notify();
	public final native void notifyAll();
	public final native void wait(long timeout) throws InterruptedException;
	public native int hashCode();
	...
}
```
이처럼 모든 클래스의 조상인 Object클래스의 메서드들은 대부분 네이티브 메서드이다.     
네이티브 메서드는 자바로 정의되어 있기 때문에 호출하는 방법은 자바의 일반 메서드와 다르지 않지만     
실제로 호출되는 것은 OS의 메서드이다.      
아무런 내용이 없는 네이티브 메서드를 선언해 놓고 호출한다고 되는 것은 아니고,           
자바에 정의된 네이티브 메서드와 OS의 메서드를 연결해주는 작업이 필요하다.          
이 역할은 JNI Java Native Interface가 한다.

## 애너테이션 타입 정하기

새로운 애너테이션을 정의하는 방법은 @기호를 붙이는 것을 제외하면 인터페이스를 정의하는 것과 동일하다.

```java
@interface 애너테이션이름 {
	타입 요소이름();		//애너테이션의 요소를 선언한다.
	...
}
```

엄밀히 말해서 @Override는 애너테이션이고 Override는 애너테이션의 타입이다.

#### 애너테이션의 요소

애너테이션 내에 선언된 메서드를 애너테이션의 요소라고 한다.       
애너테이션도 인터페이스처럼 상수를 정의할 수 있지만, 디폴트 메서드는 정의할 수 없다.

```java
@interface TestInfo {
	int count();
	String testedBy();
	String[] testTools();
	TestType testType();	//enum TestType{ FIRST, FINAL }
	DateTime testDate();	//자신이 아닌 다른 애너테이션@DateTime을 포함할 수 있다.
}
@interface DateTime {
	String yymmdd;
	String hhmmss;
}
```

애너테이션의 요소는 반환값이 있고 매개변수는 없는 추상 메서드의 형태를 가지며, 상속을 통해 구현하지 않아도 된다.      
다만, 애너테이션을 적용할 때는 이 요소들의 값을 빠짐없이 지정해주어야 한다. 순서는 상관없다.

```java
@TestInfo(
	count = 3, TestedBy= "Kim",
	testTools = {"JUnit", "AutoTester"},
	testType = TestType.FIRST,
	testDate = @DateTime(yymmdd = "220309", hhmmss = "180130")
)
public class NewClass { ... }
```

애너테이션의 각 요소는 기본값을 가질 수 있으며, 기본값이 있는 요소는 애너테이션을 적용할 때 값을 지정하지 않으면 기본값이 사용된다.

```java
@interface Testinfo {
	int count() default 1;		//기본값을 1로 지정
}

@TestInfo		//@TestInfo(count =1)과 동일
class NewClass {...}
```

애너테이션 요소가 하나뿐이고 이름이 value인 경우 애너테이션을 적용할 때 요소의 이름을 생략하고 값만 적어도 된다.

```java
@interface TestInfo {
	String value();
}
@TestInfo("passed")		//@TestInfo(value = "passed")와 동일
class NewClass { ... }
```

요소의 타입이 배열인 경우 괄호{}를 사용해서 여러 개의 값을 지정할 수 있다.

```java
@interface TestInfo {
	String[] testTools();
}
@Test(testTools = {"JUnit", "AutoTester"})	//값이 여러개인 경우
@Test(testTools = "JUnit")		//값이 하나일 때는 괄호{} 생략 가능
@Test(testTools = {})			//값이 없을 때는 괄호{}가 반드시 필요
```

기본값을 지정할 때도 마찬가지로 괄호{}를 사용할 수 있다.

```java
@interface TestInto {
	String[] info() default {"aaa", "bbb"};	//기본값이 여러개인 경우. 괄호{} 가능
	String[] info2() default "ccc";			//기본값이 하나인 경우. 괄호 생략 가능
}
@TestInfo		//@TestInfo(info = {"aaa", "bbb"}, info2 = "ccc")와 동일
@TestInfo(info2 = {})	//@TestInfo(info = {"aaa", "bbb"}, info2 = {})와 동일
class NewClass { ... }
```

요소의 타입이 배열일 때도 요소의 이름이 value면 요소의 이름을 생략할 수 있다.    
예를 들어, @SuppressWarnings의 경우 요소의 타입이 String배열이고 이름이 value이다.

```java
@interface SuppressWarnings {
	String[] value();
}

//그리고 애너테이션을 적용할 때 요소의 이름을 생략할 수 있는 것이다.

//@SuppressWarnings(value = {"deprecation", "unchecked"})
@SuppressWarnings({"deprecation", "unchecked"})
class NewClass { ... }
```


#### java.lang.annotation.Annotation
모든 애너테이션의 조상은 Annotation이다.      
그러나 애너테이션은 상속이 허용되지 않으므로 아래와 같이 명시적으로 Annotation을 조상으로 지정할 수 없다.
게다가 아래의 소스에서 볼 수 있듯이 Annotation은 애너테이션이 아니라 일반적인 인터페이스로 정의되어 있다.     

```java
package java.lang.annotation;

public interface Annotation {		//Annotation 자신은 인터페이스이다.
	boolean equals(Object obj);
	int hashCode();
	String toString();
	
	class<? extends Annotation> annotationType();	//애너테이션의 타입을 반환
}
```

모든 애너테이션의 조상인 Annotation인터페이스가 위와 같이 정의되어 있기 때문에,     
모든 애너테이션 객체에 대해 equals(), hashCode(), toString()과 같은 메서드를 호출하는 것이 가능하다.

```java
class<AnnotationTest> cls = AnnotationTest.class;
Annotation[] annoArr = AnnotationTest.class.getAnnotations();

for(Annotation a : annoArr) {
	System.out.println(a.toString());
	System.out.println(a.hashCode());
	System.out.println(a.equals(a));
	System.out.println(a.annotationTest());
}
```
위의 코드는 AnnotationTest클래스에 적용된 모든 애너테이션에 대해 toString(), hashCode(), equals()를 호출한다.

#### 마커 애너테이션 Marker Annotation
값을 지정할 필요가 없는 경우, 애너테이션의 요소를 하나도 정의하지 않을 수 없다.       
Serializable이나 Cloneable인터페이스처럼, 요소가 하나도 정의되지 않은 애너테이션을 마커 애너테이션이라고 한다.

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override{}		//마커 애너테이션. 정의된 요소가 하나도 없다.

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Test{}			//마커 애너테이션. 정의된 요소가 하나도 없다.
```

#### 애너테이션 요소의 규칙

> 요소의 타입은 기본형, String enum, 애너테이션, Class만 허용된다.       
> ()안에 매개변수를 선언할 수 없다.        
> 예외를 선언할 수 없다.       
> 요소를 타입 매개변수로 정의할 수 없다.       

```java
@interface AnnoTest {
	int id = 100;						//상수 선언. static final int id = 100;
	String major(int i, int j);			//에러. 매개변수를 선언할 수 없음
	String minor() throws Exception;	//예러. 예외를 선언할 수 없음
	ArrayList<T> list();				//에러. 요소의 타입에 타입 매개변수 사용불가
}
```
```java
@Deprecated
@SuppressWarnings("1111")		//유효하지 않은 애너테이션은 무시된다.
@TestInfo(testedBy = "aaa", testDate = @DateTime(yymmdd="220309", hhmmss = "191930"))

public class AnnotationEx5 {

	public static void main(String[] args) {
		//AnnotationEx5의 class 객체를 얻는다.
		Class<AnnotationEx5> cls = AnnotationEx5.class;
		
		TestInfo anno = (TestInfo)cls.getAnnotation(TestInfo.class);
		System.out.println(anno.testedBy());				//aaa
		System.out.println(anno.testDate().yymmdd());		//220309
		System.out.println(anno.testDate().hhmmss());		//191930
		
		for(String str : anno.testTools())
			System.out.println(str);						//JUnit
		
		//AnnotationEx5에 적용된 모든 애너테이션을 가져온다.
		Annotation[] annoArr = cls.getAnnotations();
		
		for(Annotation a : annoArr)
			System.out.println(a);
//@java.lang.Deprecated(forRemoval=false, since="")
//@tmp.TestInfo(count=1, testType=FIRST, testTools={"JUnit"}, testedBy="aaa", testDate=@tmp.DateTime(yymmdd="220309", hhmmss="191930"))
	}
}
@Retention(RetentionPolicy.RUNTIME)		//실행 시에 사용가능하도록 지정
@interface TestInfo {
	int count() default 1;
	String testedBy();
	String[] testTools() default "JUnit";
	TestType testType() default TestType.FIRST;
	DateTime testDate();
}
@Retention (RetentionPolicy.RUNTIME)	//실행 시에 사용가능하도록 지정
@interface DateTime {
	String yymmdd();
	String hhmmss();
}
enum TestType {FIRST, FINAL}
```

애너테이션을 직접 정의하고, 애너테이션의 요소의 값을 출력하는 방법을 알려주는 예제이다.   
AnnotationEx5클래스에 적용된 애너테이션을 실행시간에 얻으려면, 아래와 같이 하면 된다.

```java
Class<AnnotationEx5> cls = AnnotationEx5.class;
TestInfo anno = (TestInfo)cls.getAnnotation(TestInfo.class);
```
AnnotationEx5.class는 클래스 객체를 의미하는 리터럴이다.    
모든 클래스 파일은 클래스로더에 의해 메모리에 올라갈 때, 클래스에 대한 정보가 담긴 객체를 생성하는데     
이 객체를 클래스 객체라고 한다. 이 객체를 참조할 때는 클래스이름.class의 형식을 사용한다.      
클래스 객체에는 해당 클래스에 대한 모든 정보를 가지고 있는데, 애너테이션의 정보도 포함되어 있다.     
클래스 객체가 가지고 있는 getAnnotation()이라는 메서드에 매개변수로 정보를 얻고      
자바는 애너테이션을 지정해주거나 getAnnotations()로 모든 애너테이션을 배열로 받아올 수 있다.

```java
TestInfo anno = (TestInfo)cls.getAnnotation(TestInfo.class);
System.out.println(anno.testedBy());

//AnnotationEx5에 적용된 모든 애너테이션을 가져온다.
Annotation[] annoArr = cls.getAnnotations();
```
